System cargoservice

// MESSAGES
Request createProduct 		:	createProduct(Name)
Reply	createdProduct		:	createdProduct(PID) for createProduct

Request	deleteProduct		:	deleteProduct(PID)
Reply	deletedProduct		:	deletedProduct(Name) for deleteProduct

Request	getProduct		:	getProduct(PID)
Reply	addedProduct 		:	product(Name) for getProduct

Request	loadProduct		:	loadProduct(PID, Weigth)
Reply	loadAccepted		:	loadAccepted(Ok) for loadProduct
Reply	loadRefused		:	loadRefused(Cause) for loadProduct

Dispatch containerWaiting	:	containerWaiting(V)

Dispatch distance			:	distance(D)
Event	stop				:	stop(V)
Event	resume				:	resume(V)

Dispatch goToWait			:	goToWait(V)


// CONTEXT
Context ctxcargoservice	ip[host="localhost" port=8001]
Context ctxioport		ip[host="localhost" port=8002]
Context ctxcargorobot	ip[host="localhost" port=8003]

// contexts for tests
Context ctxtestcargo		ip[host="localhost" port=8004]


// ACTORS
// actors operating on the hold
QActor productservice context ctxcargoservice {
	State init initial {
		println("$name: STARTING...") color cyan
		
		delegate createProduct	to	dbwrapper
		delegate deleteProduct	to	dbwrapper
		delegate getProduct		to	dbwrapper
		
		println("$name: initialization complete") color cyan
	}
}

QActor cargoservice context ctxcargoservice {
	[#
			val MAX_LOAD = 100
			
			var totalWeigth = 0.0
	#]
	
	State init initial {
		println("$name: STARTING...") color blue
		
		println("$name: initialization complete") color blue
	}
	Goto wait
	
	State wait {		
		println("$name: waiting for requests...") color blue
	}
	Transition t0
		whenRequest loadProduct ->	loadproduct
		whenEvent	stop		->	stop
		
	State loadproduct {
		printCurrentMessage color blue
		
		onMsg(loadProduct : loadProduct(PID, Weigth)) {
			if [# totalWeigth < MAX_LOAD #] {
				[#
					val PID = payloadArg(0).toInt()
					val weigth = payloadArg(1).toDouble()
					totalWeigth = totalWeigth + weigth
				#]
				
				request dbwrapper -m getProduct : getProduct($PID)
			} else {
				[# var Message = "Too heavy" #]
				replyTo loadProduct with loadRefused : loadRefused($Message)
				
				println("$name: load refused: too heavy") color blue
				
				autodispatch goToWait : goToWait(1)
			}
		}
	}
	Transition t1
		whenReply	getProductAnswer	->	getproductanswered
		whenMsg		goToWait			->	wait
		
	State getproductanswered {
		onMsg(getProductAnswer : getProductAnswer(Name)) {
			[# var name = payloadArg(0) #]
			
			if [# name.equals("NOTFOUND") #] {
				[# var Message = "Not found" #]
				replyTo loadProduct with loadRefused : loadRefused($Message)
				
				println("$name: load refused: product does not exist") color blue
			} else {
				replyTo loadProduct with loadAccepted : loadAccepted(1)
				
				println("$name: load accepted") color blue
			}
		}
	}
	Goto wait
	
	State stop {
		printCurrentMessage color blue
		
		println("$name: STOPPED")
	}
	Transition t1
		whenRequest	loadProduct	->	rejectRequestWhileStopped
		whenEvent 	resume		->	resume
	
	State rejectRequestWhileStopped {
		printCurrentMessage color blue
		
		onMsg(loadProduct : loadProduct(PID, Weigth)) {
			replyTo loadProduct with loadRefused : loadRefused("System is stopped")
			
			println("$name: system stopped, request refused")
		}
	}
	Goto stop
	
	State resume {
		printCurrentMessage color blue
		
		println("$name: RESUME") color blue
		
		returnFromInterrupt
	}
}

QActor holdmanager context ctxcargoservice {
	State init initial {
		println("$name: STARTING...") color yellow
		
		[# const val SLOTS = System.getenv("SLOTS") #]
		
		println("$name: initialization complete") color yellow
	}
	Goto wait
	
	State wait {
		println("$name: waiting...") color yellow
	}	
}

QActor dbwrapper context ctxcargoservice {
	// in the future there will be a DB
	[# var DB = ArrayList<String>() #]
		
	State init initial {
		println("$name: STARTING...") color yellow
		
		println("$name: initialization complete") color yellow
	}
	Goto wait
	
	State wait {
		println("$name: waiting...") color yellow
	}
	Transition t0
		whenRequest getProduct	->	getproduct
		
		State createproduct {
		printCurrentMessage color cyan
		
		onMsg(createProduct : createProduct(Name)) {
			[#
				val name = payloadArg(0)
				DB.add(name)
				var PID = DB.indexOf(name)
			#]
			
			replyTo createProduct with createdProduct : createdProduct($PID)
		}
	}
	Goto wait
	
	State deleteproduct {
		printCurrentMessage color cyan
		
		onMsg(deleteProduct : deleteProduct(PID)) {
			[#
				val PID = payloadArg(0).toInt()
				var Name = DB.get(PID)
				DB.removeAt(PID)
			#]
			
			replyTo deleteProduct with deletedProduct : deletedProduct($Name)
		}
	}
	Goto wait
	
	State getproduct {
		printCurrentMessage color cyan
		
		onMsg(getProduct : getProduct(PID)) {
			[#
				val PID = payloadArg(0).toInt()
				var Name = DB.getOrNull(PID)
				
				if(Name == null) {
					Name = "NOTFOUND"
				}
			#]
			
			replyTo getProduct with getProductAnswer : getProductAnswer($Name)
		}
	}
	Goto wait
}

QActor holdstatusgui context ctxcargoservice {
	State init initial {
		println("$name: STARTING...") color yellow
	}
	Goto show
	
	State show {
		println("$name: showing informations...") color yellow
	}
}



// actors operating on the ioport
QActor sonarwrapper context ctxioport {
	import "java.io.*"
	[#
		lateinit var p : Process
		lateinit var reader : BufferedReader 
	#]
	
	State init initial {
		println("$name: STARTING...") color magenta
		
		[#
			const val DFREE = System.getenv("DFREE")
			
			// python script given by the client
			try {
				p = Runtime.getRuntime().exec("python sonar.py")
				reader = BufferedReader(InputStreamReader(p.getInputStream()))
			} catch(e : Exception) {
				println("sonardevice sonarStart ERROR: $e")
			}
		#]
		
		println("$name: initialization complete") color magenta
	}
	Goto sendsonardata
	
	State sendsonardata {
		[#
			try {
				var D = reader.readLine()
				if(D != null) {
					val payload = "distance( ${D} )"
					val distance = MsgUtil.buildDispatch("sonarwrapper", "distance", payload, "alarmwrapper")
					
					forward(distance)
				}
			} catch(e : Exception) {
				println("sonarwrapper sendsonardata ERROR: $e")
			}
		#]
		
		if [# D < DFREE / 2 #] {
			[#
				val containerWaiting = MsgUtil.buildDispatch("sonarwrapper", "containerWaiting", "1", "cargorobot")
			#]
		}
	}
	Goto sendsonardata
}

QActor alarmdevice context ctxioport {
	[# lateinit var p : Process #]
	
	State init initial {
		println("$name: STARTING...") color red
		
		[# p = machineExec("python ledPython25Off.py") #]
		
		[#
			var timetostop = 0	
			var timetoresume = 0
			var alarm = 0
		#]
		
		println("$name: initialization complete") color red
	}
	Goto waitfordata
	
	State waitfordata {
		println("$name: waiting for data...") color red
	}
	Transition t0
		whenMsg distance -> evaluate
		
	State evaluate {
		printCurrentMessage color red
		
		onMsg (distance : distance(D)){
			[# val D = payloadArg(0).toInt() #]
			
			if [# alarm == 0 #] {
				if [# D > DFREE #] {
					if [# timetostop == 0 #] {
						[# timetostop = LocalDateTime.now() #]
					} else {
						if [# timetostop.plusSeconds(3).isBefore(LocalDateTime.now()) #] {
							[# alarm = 1 #]
							
							emit stop : stop(1)
							println("$name: STOP") color red
						}
					}
				} else {
					[# timetostop = 0 #]
				}	
			}
			else {
				if [# D <= DFREE #] {
					if [# timetoresume == 0 #] {
						[# timetoresume = LocalDateTime.now() #]
					} else {
						if [# timetoresume.plusSeconds(3).isBefore(LocalDateTime.now()) #] {
							[# alarm = 0 #]
							
							emit resume : resume(1)
							println("$name: RESUME") color red
						}
					}
				}
			}
		}
	}
	Goto waitfordata
}


// actors operating on the cargorobot
QActor cargorobot context ctxcargorobot {
	State init initial {
		println("$name: STARTING...") color green
	}
	Goto idle
	
	State idle {
		println("$name: idle at home...") color green
	}
	Transition t0
		whenMsg containerWaiting -> loadContainer
		
	State loadContainer {
		printCurrentMessage color green
		
		// DO SOMETHING
		delay 10000
	}
	Transition t1
		whenEvent stop -> stop
		
	State stop {
		printCurrentMessage color green
		
		println("$name: STOPPED") color green
	}
	Transition t1
		whenEvent 	resume	->	resume
	
	State resume {
		printCurrentMessage color green
		
		println("$name: RESUME") color green
		
		returnFromInterrupt
	}
}


// test actors
QActor testcargo context ctxtestcargo {
	State init initial {
		println("$name: STARTING...")
	}
	Goto test
	
	State test {
		println("$name: sending dummy request to cargoService")
		
		request cargoservice -m loadProduct : loadProduct(123,100)
	}
	Transition t0
		whenReply	loadAccepted 	->	printanswer
		whenReply	loadRefused		->	printanswer
		
	State printanswer {
		printCurrentMessage
	}
}
