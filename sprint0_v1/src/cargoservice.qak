System sprint0
//Richieste e Scambi di messaggi - Inseriamo qui tutti i messaggi che scambieranno gli attori
Request load_product  : load_product(PID) 			    	    //richiesta di carico di un prodotto con PID
Reply   load_accepted : load_accepted(SLOT) for load_product 	//restituisce lo slot assegnato
Reply   load_refused  : load_refused(CAUSA) for load_product 	//ritorna la causa del mancato carico


//Contesti
Context ctx_cargoservice	ip [host="localhost" port=10000]
Context ctx_iodev			ip [host="localhost" port=10001]
Context ctx_test			ip [host="localhost" port=10002]
Context ctx_gui				ip [host="localhost" port=10003]

// --------  Attore di test "import" ---------
 

//Sprint0 Sviluppo cargoservice
QActor cargoservice context ctx_cargoservice {
           [#
           	var Taken_slot=arrayListOf("true","true","true","false","true")
        	val MAX_LOAD=2
        	var CURRENT_LOAD=0
        	#
        ]
    State start initial {
        println("[cargoservice] Inizia ") color blue

    }
    
    Goto waiting_for_request
    
    State waiting_for_request{
        println("[cargoservice] Sta aspettando richieste")color blue
    }
    
    Transition t0
    	whenRequest load_product -> handleRequest

    State handleRequest {
		    
		    println("[cargoservice] Riceve richiesta di caricamento") color blue
		    
		    [#
		    		
		    var Causa="MAX_LOADreached"	 
		    var Reserved_slot=0   	
		    
		    if( CURRENT_LOAD<MAX_LOAD) {
		   	Causa="Nessuno_slot_libero"
		    for(i in 0..4){
		    if (Taken_slot[i]=="false") {
		    CURRENT_LOAD=CURRENT_LOAD+1
		    Reserved_slot = i+1
		    Taken_slot[i]="true"
		    break;
		    	
		    }
		    }
		    }#]
		    
		    // Aggiungo un peso fittizio di uno per testare il raggiungimento di max load
		    // in futuro verrÃ  aggiunto l'effettivo peso
		    if [#Reserved_slot!=0#]{
		    replyTo load_product with load_accepted : load_accepted($Reserved_slot)
		    }else{
		    
		    replyTo load_product with load_refused : load_refused($Causa)	
		    }
		    
		 
	}
	Goto waiting_for_request
		
}


// ---------------- prossimi sprint ------------
QActor webgui context ctx_gui {
    State s0 initial {
        println("[webgui] starts in state s0 [Initial State]!") color blue
    }

    State s1 {
        
        println("[webgui] is now in state s1.") color green

    }
}

QActor sonar context ctx_iodev {
   
    State s0 initial {
        println("sonar starts in state s0 [Initial State]!") color blue
    }
}

QActor led context ctx_iodev {
   
    State s0 initial {
        println("led starts in state s0 [Initial State]!") color blue
    }

    State s1 {
        
        println("led is now in state s1.") color green

    }
}

QActor cargotest context ctx_cargoservice{
	   
    State start initial { 
        println("[cargotest] Inizia") color yellow
    }
    Goto richiesta

    State richiesta {
       println("[cargotest] Invia una nuova richiesta") color yellow
        //Invio della richiesta
        request cargoservice -m load_product:load_product(1) 
        request cargoservice -m load_product:load_product(1) 
        request cargoservice -m load_product:load_product(1) 
        }
        Goto waiting_for_response 
        State waiting_for_response{
        	
        }
		Transition t0 
        whenReply load_accepted -> loadAccepted
         whenReply load_refused -> loadRefused
        
    State loadAccepted{
		    println("[cargotest] risposta arrivata") color blue  
           onMsg( load_accepted : load_accepted(SLOT) ){
           [#val Msg=payloadArg(0).toInt()        #]
   	println("[cargotest] Richiesta accettata, slot n. $Msg ") color yellow
   }} 
   Goto waiting_for_response

    State loadRefused{

	onMsg( load_refused : load_refused(CAUSA) ){
        [#
       var Msg=payloadArg(0)
       #]
           	println("[cargotest] Richiesta rifiutata causa : $Msg ") color yellow
    }
}
	Goto waiting_for_response

}

QActor cargorobot context ctx_cargoservice{
	State start initial { 
        println("[cargorobot] Inizia") color yellow
    }
}
