System sprint1



// messaggi product service
Request createProduct : product(String)                    
Reply   createdProduct: productid(ID) for createProduct 

Request getAllProducts : dummy( ID )
Reply   getAllProductsAnswer: products(  String ) for getAllProducts 

Request getProduct 		: product( ID )  
Reply   getProductAnswer: product( JSonString ) for getProduct 


//messaggi cargoservice
Request load_product 		: product( ID )  
Reply   loadedProduct 		: slot( SLOT ) for load_product 


//messaggi tra cargoservice e cargorobot
Request move_product 		: product(SLOT)  
Reply   movedProduct 		: result( SLOT ) for load_product 



//alcuni messaggi basicrobot(da completare)
Request moverobot    :  moverobot(TARGETX, TARGETY)  
Reply moverobotdone  :  moverobotdone(ok)                    for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot
Request engage        : engage(OWNER, STEPTIME)	
Reply   engagedone    : engagedone(ARG)    for engage
Reply   engagerefused : engagerefused(ARG) for engage
    
    
       
//contesti  
Context ctx_cargoservice	ip [host="127.0.0.1" port=8111]
Context ctx_basicrobot ip [host="127.0.0.1" port=8020] 
Context ctx_cargo	ip [host="localhost" port=8000]





//attori esterni (basicrobot utilizzato da cargorobot e productservice utilizzato da cargoservice 
ExternalQActor basicrobot context ctx_basicrobot
ExternalQActor productservice context ctx_cargoservice




//cargorobot
QActor cargorobot context ctx_cargo{
	
	[#
		val Myname = "$name"
		var CurrentRequestSlot = 0
	#]
	
	State start initial{
		println("[cargorobot] STARTED ") color yellow
		request basicrobot -m engage:engage($Myname,350) 
	}

	 Transition t0 
	 whenReply engagedone -> waiting_for_request
	 whenReply engagerefused -> engage_refused
	 
	 State engage_refused{
	 	onMsg(engagerefused:engagerefused(ARG)){
		 	[#val Msg=payloadArg(0)#]
		 	println("[cargorobot] Engage refused motivo:$Msg")
	 	}
	 	
	 }
	 
	 State waiting_for_request{
	 	onMsg(engagedone:engagedone(ARG)){
	 		println("[cargorobot] waiting for request") color yellow
	 		
	 	}
	 }
	 
	Transition t0
	whenRequest move_product -> goto_IOPort
	
	State goto_IOPort{
		onMsg(move_product: product(SLOT)){
            [# var CurrentRequestSlot = payloadArg(0).toInt()
            	val X=1
            	val Y=5#
            ]
            println("[cargorobot] Ricevuto move_product, slot richiesto: $CurrentRequestSlot")
            delay 3000
            request basicrobot -m moverobot:moverobot(0,4)
            println("sent ") color yellow
        }
	}
	
	Transition t0
	whenReply moverobotfailed-> return_home_anyway
	whenReply moverobotdone -> goto_slot
	State goto_slot{
		println("gotoslot")
		delay 3000
		onMsg(moverobotdone  :  moverobotdone(ok)){
		[#
			val XSlot=4
			val YSlot=4
			
		#]
		println("gotoslot")
		request basicrobot -m moverobot:moverobot(1,3)
		
		}
	}
	Transition t0
	whenReply moverobotdone -> return_home
	whenReply moverobotfailed-> return_home_anyway
	
	State return_home{
		delay 3000
		onMsg(moverobotdone  :  moverobotdone(ok)){
			request basicrobot -m moverobot:moverobot(0,0)
		
		}
		}
		Transition t0
		whenReply moverobotdone -> waiting_for_request
		whenReply moverobotfailed-> waiting_for_request
		State return_home_anyway{
			println("returnhomeanyway")
			delay 3000
			onMsg(moverobotfailed:moverobotfailed(PLANDONE, PLANTODO)){
				request basicrobot -m moverobot:moverobot(0,0)
			}
			
		}
		Transition t0
		whenReply moverobotdone -> waiting_for_request
		whenReply moverobotfailed-> waiting_for_request			
	}
	
	// notify cargoservice (?)







// cargoservice 
QActor cargoservice context ctx_cargo{
     [#
       	var Taken_slot=arrayListOf("false","false","false","false","true")
    	val MAX_LOAD=100
    	var CURRENT_LOAD=0
    	var Product_weight = 0
    	var Reserved_slot = 0
     #]
         
	State start initial{
		println("[cargoservice] STARTED ") color yellow
	}
	Goto waiting_for_request
	 
	 
	 State waiting_for_request{
	 	
	 	println("[cargoservice] waiting for request") color yellow
	 }
	 
	Transition t0
	whenRequest load_product -> check_product
	
	State check_product{
		
		onMsg(load_product: product(ID)){	
			println("[cargoservice] check del prodotto")	
			[#
				val ID=payloadArg(0).toInt()
			#]			
			request productservice -m getProduct:product($ID)	
		}
		
	}
	Transition t0
	whenReply getProductAnswer -> check_load
	
	
	State check_load{
	
		onMsg(getProductAnswer: product(JsonString)){
			println("[cargoservice] arrivato peso")
			[#
				val Product=payloadArg(0)					
				Product_weight = main.java.Product.getJsonInt(Product, "weight")
			#]
		}
	}
	
	Goto moveProduct if [#CURRENT_LOAD+ Product_weight <= MAX_LOAD #] else too_much_weight
	
	State too_much_weight{
		println("Il carico eccederebbe maxload, non è possibile eseguire la load")
	}
	Goto waiting_for_request
	
	State moveProduct{
		println("[cargoservice] ingresso move product")
		[# 
			CURRENT_LOAD += Product_weight		      
		    Reserved_slot=0   
		    for(i in 0..4){
			    if (Taken_slot[i]=="false") {
				    Reserved_slot = i+1
				    Taken_slot[i]="true"
				    break;		    	
			    }
		    }
		#]
		request cargorobot -m move_product:product($Reserved_slot) 
		println("[cargoservice] richiesta di move al basic robot mandata")
	}
		
	Transition t0
	whenReply movedProduct -> load_finished
	
	State load_finished{
		onMsg(movedProduct:result( SLOT )){
			println("Load completata il robot è in home ")		
		}
	}
	Goto waiting_for_request
}













QActor test context ctx_cargo{
	State start initial{
		println("[test] avviato") color blue  
		[#
			val Myname = "$name"
			val Product="'{\"productId\":1,\"name\":\"p2\",\"weight\":100}'"
		#]
		println("$Myname | creating product: $Product") color blue
		request productservice -m createProduct: product($Product)
		println("[test]  mandata richiesta") color yellow 
	}	
		
	Transition t0
	whenReply createdProduct-> createdProduct
	
//	State createdProduct{
//		[#
//			val Product="'{\"productId\":1,\"name\":\"p2\",\"weight\":100}'"
//			val ProductID=1
//		#]
//			request productservice -m createProduct:product($Product)
//			println("[test]  mandata richiesta") color yellow 
//	}
			
//			request productservice -m getProduct : product($ProductID)
		
		
		

		
		
		
//		request productservice -m getProduct : product($ProductID)
//		request productservice -m getAllProducts:dummy($ProductID)

      //   	whenReply engagedone -> allProductsRecieved
        
    State createdProduct{
		println("[test]aaaaaaaaaaaaaaaaaa richiesta") color yellow 
		onMsg(createdProduct : productid(ID) ){
			println("[test]aaaaaaaaaaaaaaaaaa richiesta") color yellow 
			[# val ID=payloadArg(0)+1 #]
	           
	   		println("[test] prodotto creato ID: $ID") color yellow
			request cargoservice -m load_product : product($ID)
			println("[test] Ho chiesto la load del prodotto appena creato a cargoservice") color yellow		
	   
	   }
   }  
   Transition t0
   whenReply loadedProduct-> moved
   State moved{
   
   onMsg(loadedProduct:slot(SLOT)){
			println("funzionamento")
		}
		
		}
   State allProductsRecieved{

}
   State productRecieved{
   	printCurrentMessage
   }
} 













































//
//Request load_product  : load_product(PID) 			    	    //richiesta di carico di un prodotto con PID
//Reply   load_accepted : load_accepted(SLOT) for load_product 	//restituisce lo slot assegnato
//Reply   load_refused  : load_refused(CAUSA) for load_product 	//ritorna la causa del mancato carico
//
//Context ctx_cargoservice	ip [host="localhost" port=10000]
//Context ctx_iodev			ip [host="localhost" port=10001]
//Context ctx_test			ip [host="localhost" port=10002]
//Context ctx_gui				ip [host="localhost" port=10003]
//
//QActor cargoservice context ctx_cargoservice {
//           [#
//           	var Taken_slot=arrayListOf("true","true","true","false","true")
//        	val MAX_LOAD=2
//        	var CURRENT_LOAD=0
//        	#
//        ]
//    State start initial {
//        println("[cargoservice] Inizia ") color blue
//
//    }
//    
//    Goto waiting_for_request
//    
//    State waiting_for_request{
//        println("[cargoservice] Sta aspettando richieste")color blue
//    }
//    
//    Transition t0
//    	whenRequest load_product -> handleRequest
//
//    State handleRequest {
//		    
//		    println("[cargoservice] Riceve richiesta di caricamento") color blue
//		    
//		    [#
//		    		
//		    var Causa="MAX_LOADreached"	 
//		    var Reserved_slot=0   	
//		    
//		    if( CURRENT_LOAD<MAX_LOAD) {
//		   	Causa="Nessuno_slot_libero"
//		    for(i in 0..4){
//		    if (Taken_slot[i]=="false") {
//		    CURRENT_LOAD=CURRENT_LOAD+1
//		    Reserved_slot = i+1
//		    Taken_slot[i]="true"
//		    break;
//		    	
//		    }
//		    }
//		    }#]
//		    
//		    // Aggiungo un peso fittizio di uno per testare il raggiungimento di max load
//		    // in futuro verrà aggiunto l'effettivo peso
//		    if [#Reserved_slot!=0#]{
//		    replyTo load_product with load_accepted : load_accepted($Reserved_slot)
//		    }else{
//		    
//		    replyTo load_product with load_refused : load_refused($Causa)	
//		    }
//		    
//		 
//	}
//	Goto waiting_for_request
//		
//}