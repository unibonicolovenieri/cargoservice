System sprint1



// messaggi product service
Request createProduct : product(String)                    
Reply   createdProduct: productid(ID) for createProduct 
Request getAllProducts : dummy( ID )
Reply   getAllProductsAnswer: products(  String ) for getAllProducts 
Request getProduct 		: product( ID )  
Reply   getProductAnswer: product( JSonString ) for getProduct 


//messaggi cargoservice
Request load_product 		: product( ID )  
Reply   loadedProduct 		: slot( slot_id ) for load_product 


//messaggi tra cargoservice e cargorobot
Request move_product 		: product( ID, SLOT)  
Reply   movedProduct 		: result( SLOT ) for load_product 



//alcuni messaggi basicrobot(da completare)
Request moverobot    :  moverobot(TARGETX, TARGETY)  
Reply moverobotdone  :  moverobotok(ARG)                    for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot
 Request engage        : engage(OWNER, STEPTIME)	
    Reply   engagedone    : engagedone(ARG)    for engage
    Reply   engagerefused : engagerefused(ARG) for engage
    
    
    
    
//contesti  
Context ctx_productservice	ip [host="127.0.0.1" port=8111]
Context ctx_cargotest	ip [host="localhost" port=8112]
Context ctx_basicrobot ip [host="127.0.0.1" port=8020] 
Context ctx_cargoservice	ip [host="localhost" port=8110]





//attori esterni (basicrobot utilizzato da cargorobot e productservice utilizzato da cargoservice 
ExternalQActor basicrobot context ctx_basicrobot
ExternalQActor productservice context ctx_productservice







// cargoservice 
QActor cargoservice context ctx_cargoservice{
	     [#
           	var Taken_slot=arrayListOf("false","false","false","false","true")
        	val MAX_LOAD=2
        	var CURRENT_LOAD=0
        	var Product_weight = 0
        	var Reserved_slot = 0
         #]
	State start initial{
		println("[cargoservice] STARTED ") color yellow
		delay 1000
	}
	Goto waiting_for_request
	 
	 
	 State waiting_for_request{
	 	println("[cargoservice] waiting for request") color yellow
	 }
	 
	Transition t0
	whenRequest load_product -> check_product
	
	State check_product{
		
		onMsg(load_product: product(ID)){		
			[#
				val ID=payloadArg(0).toInt()
			#]			
			request cargoservice -m getProduct:product($ID)	
		}
		
	}
	Transition t0
	whenReply getProductAnswer -> check_load
	
	
		State check_load{
		
		onMsg(getProductAnswer: product(JsonString)){
		
		[#
			val Product=payloadArg(0)
			var Product_weight_tmp = 1 // main.java.Product.getJsonInt(Product, "weight") qui dava errore
			Product_weight = Product_weight_tmp
		#]
		}
		}
		Goto moveProduct if [#CURRENT_LOAD+ Product_weight <= MAX_LOAD #] else too_much_weight
		State too_much_weight{
			println("Il carico eccederebbe maxload, non è possibile eseguire la load")
		}
		Goto waiting_for_request
		
		State moveProduct{
			
		[# 
			CURRENT_LOAD += Product_weight		      
		    Reserved_slot=0   
		    for(i in 0..4){
			    if (Taken_slot[i]=="false") {
				    Reserved_slot = i+1
				    Taken_slot[i]="true"
				    break;		    	
			    }
		    }
		 #]
	request cargorobot -m move_product:product($Reserved_slot) 
	}
	Transition t0
	whenReply movedProduct -> load_finished
	State load_finished{
		println("Load completata il robot è in home ")
	}
	Goto waiting_for_request
}





//cargorobot
QActor cargorobot context ctx_cargoservice{
	
	[#
		val Myname = "$name"
		var CurrentRequestSlot = 0
	#]
	
	State start initial{
		println("[cargorobot] STARTED ") color yellow
		request basicrobot -m engage:engage($Myname,300) 
	}
	
	 Transition t0 
	 whenReply engagedone -> waiting_for_request
	 whenReply engagerefused -> engage_refused
	 
	 State engage_refused{
	 	onMsg(engagerefused:engagerefused(ARG)){
	 	[#val Msg=payloadArg(0)#]
	 	println("[cargorobot] Engage refused motivo:$Msg")
	 	}
	 	
	 }
	 
	 State waiting_for_request{
	 	println("[cargorobot] waiting for request") color yellow
	 }
	 
	Transition t0
	whenRequest move_product -> goto_IOPort
	
	State goto_IOPort{
		onMsg(move_product: product(SLOT)){
            [# CurrentRequestSlot = payloadArg(0).toInt() #]
            println("[cargorobot] Ricevuto move_product, slot richiesto: $CurrentRequestSlot")
            request basicrobot -m moverobot:moverobot(5,0)
        }
	}
	Goto goto_slot
	State goto_slot{
		[#
			val XSlot=2
			val YSlot=2
			
		#]
		request basicrobot -m moverobot:moverobot($XSlot,$YSlot)
	}
	Goto return_home
	State return_home{
		request basicrobot -m moverobot:moverobot(0,0)
	}
	
	// notify cargoservice (?)
}






















QActor test context ctx_cargotest{
	State start initial{
		println("[test] avviato") color blue  
		[#
			val Myname = "$name"
			val Product="'{\"productId\":1,\"name\":\"p2\",\"weight\":100}'"
			val ProductID=1
		#]
		

		[# val Cur_prod_PID = ProductID.toInt() #]
		println("$name | checking with productservice for the weight of PID: $Cur_prod_PID") color blue
		request basicrobot -m engage:engage($Myname,300)
		println("[test]  mandata richiesta") color yellow 
	}	
		
	Transition t0
	whenReply engagedone-> createProduct
	
	State createProduct{
		[#
			val Product="'{\"productId\":1,\"name\":\"p2\",\"weight\":100}'"
			val ProductID=1
		#]
			request productservice -m createProduct:product($Product)
			println("[test]  mandata richiesta") color yellow 
	}
			
//			request productservice -m getProduct : product($ProductID)
		
		
		

		
		
		
//		request productservice -m getProduct : product($ProductID)
//		request productservice -m getAllProducts:dummy($ProductID)

	Transition t0 
	whenReply createdProduct -> createdProduct
      //   	whenReply engagedone -> allProductsRecieved
        
    State createdProduct{
		println("[test]aaaaaaaaaaaaaaaaaa richiesta") color yellow 
		onMsg(createdProduct : productid(ID) ){
			println("[test]aaaaaaaaaaaaaaaaaa richiesta") color yellow 
			[# val Msg=payloadArg(0)+1 #]
	           
	   		println("[cargotest] Richiesta accettata, slot n. $Msg ") color yellow
	   		println("Engaged") color yellow
			request basicrobot -m moverobot : moverobot($Msg,$Msg)
			println("Engaged") color yellow		
	   
	   }
   }  
   Transition t0
   whenReply moverobotdone-> moved
   State moved{
   
   onMsg(moverobotdone:moverobotdone(A,B)){
			println("funzionamento")
		}
		
		}
   State allProductsRecieved{
   	println("Engaged") color yellow
		[#val X=1
			val Y=1#
		]
}
   State productRecieved{
   	printCurrentMessage
   }
} 













































//
//Request load_product  : load_product(PID) 			    	    //richiesta di carico di un prodotto con PID
//Reply   load_accepted : load_accepted(SLOT) for load_product 	//restituisce lo slot assegnato
//Reply   load_refused  : load_refused(CAUSA) for load_product 	//ritorna la causa del mancato carico
//
//Context ctx_cargoservice	ip [host="localhost" port=10000]
//Context ctx_iodev			ip [host="localhost" port=10001]
//Context ctx_test			ip [host="localhost" port=10002]
//Context ctx_gui				ip [host="localhost" port=10003]
//
//QActor cargoservice context ctx_cargoservice {
//           [#
//           	var Taken_slot=arrayListOf("true","true","true","false","true")
//        	val MAX_LOAD=2
//        	var CURRENT_LOAD=0
//        	#
//        ]
//    State start initial {
//        println("[cargoservice] Inizia ") color blue
//
//    }
//    
//    Goto waiting_for_request
//    
//    State waiting_for_request{
//        println("[cargoservice] Sta aspettando richieste")color blue
//    }
//    
//    Transition t0
//    	whenRequest load_product -> handleRequest
//
//    State handleRequest {
//		    
//		    println("[cargoservice] Riceve richiesta di caricamento") color blue
//		    
//		    [#
//		    		
//		    var Causa="MAX_LOADreached"	 
//		    var Reserved_slot=0   	
//		    
//		    if( CURRENT_LOAD<MAX_LOAD) {
//		   	Causa="Nessuno_slot_libero"
//		    for(i in 0..4){
//		    if (Taken_slot[i]=="false") {
//		    CURRENT_LOAD=CURRENT_LOAD+1
//		    Reserved_slot = i+1
//		    Taken_slot[i]="true"
//		    break;
//		    	
//		    }
//		    }
//		    }#]
//		    
//		    // Aggiungo un peso fittizio di uno per testare il raggiungimento di max load
//		    // in futuro verrà aggiunto l'effettivo peso
//		    if [#Reserved_slot!=0#]{
//		    replyTo load_product with load_accepted : load_accepted($Reserved_slot)
//		    }else{
//		    
//		    replyTo load_product with load_refused : load_refused($Causa)	
//		    }
//		    
//		 
//	}
//	Goto waiting_for_request
//		
//}