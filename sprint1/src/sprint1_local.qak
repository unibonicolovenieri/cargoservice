System sprint1



// messaggi product service
Request createProduct : product(String)                    
Reply   createdProduct: productid(ID) for createProduct 

Request getAllProducts : dummy( ID )
Reply   getAllProductsAnswer: products(  String ) for getAllProducts 

Request getProduct 		: product( ID )  
Reply   getProductAnswer: product( JSonString ) for getProduct 


//messaggi cargoservice
Request load_product 		: product( ID )  
Reply   loadedProduct 		: slot( SLOT ) for load_product 

//hold 
Event slot_changed : slot_changed(ID,status) 
Event sonar_changed : sonar_changed(status)
Event led_changed : led_changed(status)

//messaggi tra cargoservice e cargorobot
Request move_product 		: product(SLOT)  
Reply   movedProduct 		: result( SLOT ) for move_product
Reply   moveProductFailed:fail(failed) for move_product 
Event stop: stop(X)  
Event resume: resume(X) 
Event alarm           		: alarm(X)
Dispatch nextmove     : nextmove(M)
Dispatch nomoremove   : nomoremove(M)

Dispatch setdirection : dir ( D )

//alcuni messaggi basicrobot(da completare)
Request moverobot    :  moverobot(TARGETX, TARGETY)  
Reply moverobotdone  :  moverobotdone(ok)                    for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot
Request engage        : engage(OWNER, STEPTIME)	
Reply   engagedone    : engagedone(ARG)    for engage
Reply   engagerefused : engagerefused(ARG) for engage
    

//per sonar test
Event container_trigger : container_trigger(X) 
Event container_absence  : container_absence(X)    
Event sonar_error:sonar_error(CAUSA) 
Event problem_solved:problem_solved(CAUSA)


// Eventi

       
//contesti  
Context ctx_productservice	ip [host="localhost" port=8111]
Context ctx_basicrobot ip [host="localhost" port=8020] 
Context ctx_cargo	ip [host="localhost" port=8000]




//attori esterni (basicrobot utilizzato da cargorobot e productservice utilizzato da cargoservice 
ExternalQActor basicrobot context ctx_basicrobot
ExternalQActor productservice context ctx_productservice




//cargorobot
QActor cargorobot context ctx_cargo{
	
	[#
		val Myname = "$name"
		var CurrentRequestSlot = 0
		var delivering = false
		val posizione = hashMapOf(
		    "HOME"     to arrayOf(0, 0),
		    "IOport"  to arrayOf(0, 4),
		    "1"    to arrayOf(1, 1),
		    "2"    to arrayOf(1, 3),
		    "3"    to arrayOf(4, 1),
		    "4"    to arrayOf(4, 3)
		)
		
		val orientamento = hashMapOf(
			"HOME"    	to "down",
			"IOport" 	to "down",
		    "1"   	to "right",
		    "2" 	to "right",
		    "3" 	to "left",
		    "4" 	to "left"
		)
		
		var X = 0
		var Y = 0
	#]
	
	State start initial{
		delay 30000
		println("[cargorobot] STARTED ") color yellow
		request basicrobot -m engage:engage($Myname,340) 
	}

	 Transition t0 
	 whenReply engagedone -> waiting_for_request
	 whenReply engagerefused -> engage_refused
	 whenInterruptEvent sonar_error -> stop
	 State stop{
	 	
	 		emit alarm           		: alarm(X)
	 		updateResource [#"Alarm(X)"#]
	 		println("[$name] robot stopped")color yellow
	 		
	 } 
	 Transition t0 
	 //whenReply moverobotfailed-> resume
	 whenEvent problem_solved -> resume
	  
	 	 State resume{
	 	 			updateResource [#"problem_solved(solved)"#]
	 	 			forward basicrobot -m nextmove:nextmove(l)
	 	 			//request basicrobot -m engage:engage($Myname,340)
	 	 			
	}
	Transition t0 
    whenReply moverobotfailed-> reengage
    whenReply engagedone -> reengage
	State reengage{
		
			println("$name reengage done")
			
		
		
	}
	 Goto riprendocosaprecedente
	 State riprendocosaprecedente{
	 	
	 	println("[$name] robot stava consegnando e ora riprenderà il lavoro")color yellow
		request basicrobot -m moverobot:moverobot($X,$Y)
	 	
	 	println("[$name] robot rinizia il lavoro")color yellow
	 	returnFromInterrupt
	 }
	 Transition t0
	 whenReply moverobotdone-> continuaJob
	 State continuaJob{
	 	println("non sto facendo niente torno al mio lavoro")color yellow
	 	returnFromInterrupt
	 }
	 
	 State engage_refused{
	 	onMsg(engagerefused:engagerefused(ARG)){
		 	[#val Msg=payloadArg(0)#]
		 	println("[cargorobot] Engage refused motivo:$Msg")
	 	}
	 	
	 }
	 
	 State waiting_for_request{
		[#delivering = false#]
	 	onMsg(engagedone:engagedone(ARG)){
	 		println("[cargorobot] waiting for request") color yellow
	 		
	 	}
	 }
	 
	Transition t0
	whenRequest move_product -> goto_IOPort
	whenInterruptEvent sonar_error -> stop
	
	State goto_IOPort{
		onMsg(move_product: product(SLOT)){
            [# CurrentRequestSlot = payloadArg(0).toInt()
            	X = posizione["IOport"]!![0]!!
				Y = posizione["IOport"]!![1]!!
            #]
            println("[cargorobot] Ricevuto move_product, slot richiesto: $CurrentRequestSlot") color yellow
            println("Posizione X: $X Y: $Y") color yellow
            request basicrobot -m moverobot:moverobot($X,$Y)
            [#delivering = true
            	
            #]
            println("sent ") color yellow
        }
	}
	
	Transition t0
	whenReply moverobotfailed-> return_home_anyway
	whenReply moverobotdone -> goto_slot
	whenInterruptEvent sonar_error -> stop
	
	
	State goto_slot{
		println("gotoslot") color yellow
		delay 3000
		onMsg(moverobotdone  :  moverobotdone(ok)){
		[#
			X = posizione[CurrentRequestSlot.toString()]!![0]!!
			Y = posizione[CurrentRequestSlot.toString()]!![1]!!
			
		#]
		println("[gotoslot] position received") color green
		request basicrobot -m moverobot:moverobot($X,$Y)
		[#delivering = true#]
		println("gotoslot delivering: $delivering | position x: $X y: $Y") color green
		}
	}
	
	
	Transition t0
	whenReply moverobotdone -> arrived_at_slot
	whenReply moverobotfailed-> return_home_anyway
	whenInterruptEvent sonar_error -> stop
	
	State arrived_at_slot{
		println("Arrived at slot $CurrentRequestSlot")
		println("Direction") color blue
		[#
			var Direction = orientamento[CurrentRequestSlot.toString()]!!
			#
		]
		if [#CurrentRequestSlot != 3 && CurrentRequestSlot != 4#]{
			forward basicrobot -m setdirection : dir($Direction)
		println("Direction $Direction") color blue
		//Si occupa lo slot quindi faccio una emit di cambio di stato (	Serve a WebGui)
		emit slot_changed : slot_changed($CurrentRequestSlot,true)

}
		
	}
	
	Goto return_home

	
	
	State return_home{
		delay 3000
		//onMsg(moverobotdone  :  moverobotdone(ok)){
		[#
			X = posizione["HOME"]!![0]!!
			Y = posizione["HOME"]!![1]!!
			
		#]
		request basicrobot -m moverobot:moverobot($X,$Y)
		[#delivering = true#]
		
		}
		Transition t0
		whenReply moverobotdone -> arrived_at_home
		whenReply moverobotfailed-> load_failed
		whenInterruptEvent sonar_error -> stop
		
		State arrived_at_home{
		println("Arrived at home")
		println("Direction") color blue
		[#
			var Direction = orientamento["HOME"]!!
			#
		]
		forward basicrobot -m setdirection : dir($Direction)
		println("Direction $Direction") color blue
		
	}
		Goto load_completed
		
		State return_home_anyway{
			println("returnhomeanyway")
			delay 3000
			onMsg(moverobotfailed:fail(PLANDONE)){
				[#
				X = posizione["HOME"]!![0]!!
				Y = posizione["HOME"]!![1]!!
				#]
				request basicrobot -m moverobot:moverobot($X,$Y)
				 [#delivering = true#]
			}
			
		}
		
		
		Transition t0
		whenReply moverobotdone -> load_failed //????? Chiedi con Luca
		whenReply moverobotfailed-> load_failed
		whenInterruptEvent sonar_error -> stop	
		 
		
		State load_completed{
			println("[$name] load completed")
			replyTo  move_product with movedProduct:result(ok)
		}
		
		
		Goto waiting_for_request
		
		
		State load_failed{
			println("[$name] load failed")
			replyTo  move_product with moveProductFailed:fail(failed)
		}
		
		
		Goto waiting_for_request
		
	}
	
	






// cargoservice 
QActor cargoservice context ctx_cargo{
     [#
       	var Taken_slot=arrayListOf("false","false","false","false","true")
    	val MAX_LOAD=500
    	var CURRENT_LOAD=0
    	var Product_weight = 0
    	var Reserved_slot = 0
     #]
         
	State start initial{
		println("[cargoservice] STARTED ") color yellow
		delay 5000
		delay 30000
	}
	Goto waiting_for_request
	 
	 
	 State waiting_for_request{
	 	
	 	println("[cargoservice] waiting for request") color yellow
	 }
	 
	Transition t0
	whenRequest load_product -> check_product
	whenInterruptEvent sonar_error -> stop
	whenEvent container_trigger -> check_product
	
	
	
	State stop{
	onMsg(sonar_error:sonar_error(CAUSA)){
	[# val M=payloadArg(0)#]	
	
	 println("[$name] sonar ha emesso un errore causa: $M")	color yellow
	 //emit stop:stop(si) //dico al cargorobot di fermarsi
	 //Si rompe il sonar quindi emetto un segnale led 
	 emit led_changed : led_changed(Acceso)
	 }
	}
	
	
	Transition t0 
	whenEvent problem_solved -> resume
	
	 
	State resume{
	onMsg(problem_solved:problem_solved(CAUSA)){
	[# val M=payloadArg(0)#]	
	
	 println("[$name] sonar ha risolto l'errore causa: $M")	color yellow
	 //emit resume:resume(ok) //dico al cargorobot di riprendere ciò che stava facendo
	 //Il sonar si è fixato e quindi ora metto il led a spento
	emit led_changed : led_changed(Spento)
	 
	 }
	 returnFromInterrupt //provo a toglierla ma occhio - 7 novembre alle 10:32
	}
	
	
	
	
	State check_product{
		
		onMsg(container_trigger: container_trigger(X)){	
			println("[cargoservice] check del prodotto")	
			[#
				val ID=payloadArg(0).toInt()
			#]			
			request productservice -m getProduct:product($ID)	
		}
		
	}
	Transition t0
	whenReply getProductAnswer -> check_load
	whenInterruptEvent sonar_error -> stop
	
	
	State check_load{
	
		onMsg(getProductAnswer: product(JsonString)){
			println("[cargoservice] arrivato peso")
			[#
				val Product=payloadArg(0)					
				Product_weight = main.java.Product.getJsonInt(Product, "weight")
			#]
		}
	}
	
	Goto checkSlot if [#CURRENT_LOAD+ Product_weight <= MAX_LOAD #] else too_much_weight
	
	State too_much_weight{
		println("Il carico eccederebbe maxload, non è possibile eseguire la load") color yellow
	}
	Goto waiting_for_request
	
	State checkSlot{
		println("[cargoservice] ingresso move product") color yellow
		[# 
			CURRENT_LOAD += Product_weight		      
		    Reserved_slot=0   
		    for(i in 0..4){
			    if (Taken_slot[i]=="false") {
				    Reserved_slot = i+1
				    Taken_slot[i]="true"
				    break;		    	
			    }
		    }
		#]
		}
		Goto moveProduct if [#Reserved_slot!=0#] else slotEsauriti
		
		State slotEsauriti{
			println("[$name] slot esauriti") color yellow
		}
		
		
		State moveProduct{
		request cargorobot -m move_product:product($Reserved_slot) 
		println("[cargoservice] richiesta di move al cargo robot mandata") color yellow
	}
		
	Transition t0
	whenReply movedProduct -> load_finished
	whenInterruptEvent sonar_error -> stop
	
	State load_finished{
		onMsg(movedProduct:result( SLOT )){
			println("Load completata il robot è in home ")		
		}
	}
	
		
	Goto waiting_for_request
}


QActor producservice_test context ctx_cargo{
	State start initial{
		delay 30000
		println("[test] avviato") color blue  
		[#
			
			val Product="'{\"productId\":1,\"name\":\"p2\",\"weight\":100}'"
		#]
		println("$name | creating product: $Product") color blue
		request productservice -m createProduct: product($Product)
		println("[test]  mandata richiesta") color yellow 
	}	
		
	Transition t0
	whenReply createdProduct-> createdProduct
	

        
    State createdProduct{
		println("[test]aaaaaaaaaaaaaaaaaa richiesta") color yellow 
		onMsg(createdProduct : productid(ID) ){
			println("[test]aaaaaaaaaaaaaaaaaa richiesta") color yellow 
			[# val ID=payloadArg(0).toInt() #]
	           
	   		println("[test] prodotto creato ID: $ID") color yellow
	   		delay 50000
   
	   }
   }  
   Transition t0
   whenReply loadedProduct-> moved
   State moved{
   
   onMsg(loadedProduct:slot(SLOT)){
			println("funzionamento")
		}
		
		}
   
} 


QActor sonar_test context ctx_cargo {
	[# var Counter = 1 #]
	
	State start initial {
		println("$name | started ") color green
		delay 2000 
		delay 30000
	}
	Goto simulate_container_arrival
	
	
	State simulate_container_arrival {
		println("$name | Simulo arrivo container") color green
		println("$name | $Counter | numero dell'iterazione di Sonar Test") color gray       
		emit container_trigger : container_trigger(1)
		// Sonar misura una distanza piu piccola e quindi c'è un container
		emit sonar_changed :sonar_changed(Container_Individuato)
		updateResource [#"slot_changed($Counter,true)"#]
		updateResource [#"sonar_changed(Container_Individuato)"#]
		delay 10000
		
	}
	Goto simulate_container_absence
	
	
	State simulate_container_absence {
		if [# Counter % 5 == 0 #] {
			println("$name | Simulo sparizione container") color yellow
			emit container_absence : container_absence(no)
			//Sonar rileva DFREE e quindi non c'è niente e quindi è vuoto
			emit sonar_changed :sonar_changed(Container_Assente)
			updateResource [#"slot_changed($Counter,false)"#]
			updateResource [#"sonar_changed(Container_Assente)"#] 
			delay 10000
		}
	}
	Goto maybe_fail
	
	
	State maybe_fail {
		[# Counter++ #]
		if [# Counter % 2 == 0 #] {
			println("$name | Guasto sonar!") color magenta
			emit sonar_error : sonar_error(errore)
			updateResource [#"led_changed(Acceso)"#]
	 		updateResource [#"alarm(X)"#]
			
			delay 4000
			println("$name | Sonar ripristinato!") color magenta
			emit problem_solved : problem_solved(solved)
			updateResource [#"led_changed(Spento)"#]
			updateResource [#"problem_solved(solved)"#]
		}
		delay 10000
	}
	Goto simulate_container_arrival
}



//QActor webgui_test context ctx_webgui{
//	
//	State start initial {
//		println("WebGui | Started! ") color blue
//		delay 2000
//		
//		onMsg(slot_changed : slot_changed(ID,X)){
//			println("WebGui | Slot Occupato! ") color magenta
//		}
//		
//		onMsg(sonar_changed : sonar_changed(X)){
//			println("WebGui | sonar Rileva qualcosa! ") color magenta
//		}
//		
//		onMsg(led_changed : led_changed(X)){
//			println("WebGui | Il Sonar si è rotto LED ACCESO! ") color magenta
//		}
//	}
//	Transition t0
//	
//	
//	
//}





































//
//Request load_product  : load_product(PID) 			    	    //richiesta di carico di un prodotto con PID
//Reply   load_accepted : load_accepted(SLOT) for load_product 	//restituisce lo slot assegnato
//Reply   load_refused  : load_refused(CAUSA) for load_product 	//ritorna la causa del mancato carico
//
//Context ctx_productservice	ip [host="localhost" port=10000]
//Context ctx_iodev			ip [host="localhost" port=10001]
//Context ctx_test			ip [host="localhost" port=10002]
//Context ctx_gui				ip [host="localhost" port=10003]
//
//QActor cargoservice context ctx_productservice {
//           [#
//           	var Taken_slot=arrayListOf("true","true","true","false","true")
//        	val MAX_LOAD=2
//        	var CURRENT_LOAD=0
//        	#
//        ]
//    State start initial {
//        println("[cargoservice] Inizia ") color blue
//
//    }
//    
//    Goto waiting_for_request
//    
//    State waiting_for_request{
//        println("[cargoservice] Sta aspettando richieste")color blue
//    }
//    
//    Transition t0
//    	whenRequest load_product -> handleRequest
//
//    State handleRequest {
//		    
//		    println("[cargoservice] Riceve richiesta di caricamento") color blue
//		    
//		    [#
//		    		
//		    var Causa="MAX_LOADreached"	 
//		    var Reserved_slot=0   	
//		    
//		    if( CURRENT_LOAD<MAX_LOAD) {
//		   	Causa="Nessuno_slot_libero"
//		    for(i in 0..4){
//		    if (Taken_slot[i]=="false") {
//		    CURRENT_LOAD=CURRENT_LOAD+1
//		    Reserved_slot = i+1
//		    Taken_slot[i]="true"
//		    break;
//		    	
//		    }
//		    }
//		    }#]
//		    
//		    // Aggiungo un peso fittizio di uno per testare il raggiungimento di max load
//		    // in futuro verrà aggiunto l'effettivo peso
//		    if [#Reserved_slot!=0#]{
//		    replyTo load_product with load_accepted : load_accepted($Reserved_slot)
//		    }else{
//		    
//		    replyTo load_product with load_refused : load_refused($Causa)	
//		    }
//		    
//		 
//	}
//	Goto waiting_for_request
//		
//}