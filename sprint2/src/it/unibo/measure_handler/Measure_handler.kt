/* Generated by AN DISI Unibo */ 
package it.unibo.measure_handler

import it.unibo.kactor.*
import alice.tuprolog.*
import unibo.basicomm23.*
import unibo.basicomm23.interfaces.*
import unibo.basicomm23.utils.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import it.unibo.kactor.sysUtil.createActor   //Sept2023
//Sept2024
import org.slf4j.Logger
import org.slf4j.LoggerFactory 
import org.json.simple.parser.JSONParser
import org.json.simple.JSONObject


//User imports JAN2024

class Measure_handler ( name: String, scope: CoroutineScope, isconfined: Boolean=false, isdynamic: Boolean=false ) : 
          ActorBasicFsm( name, scope, confined=isconfined, dynamically=isdynamic ){

	override fun getInitialState() : String{
		return "s0"
	}
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		//val interruptedStateTransitions = mutableListOf<Transition>()
		//IF actor.withobj !== null val actor.withobj.name» = actor.withobj.method»ENDIF
		 
				val DFREE = 20 
				
				//stati
		        val START = 0
		        val CONTAINER_PRESENTE = 1
		        val CONTAINER_ASSENTE = 2
		        val GUASTO = 3
		        
				var Stato = START
				var Stato_precedente = START
				var CounterMisurazioni = 0
				
				var Guasto = false
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						CommUtils.outblack("$name | start")
						subscribeToLocalActor("sonar") 
						//genTimer( actor, state )
					}
					//After Lenzi Aug2002
					sysaction { //it:State
					}	 	 
					 transition( edgeName="goto",targetState="waiting_for_measurement", cond=doswitch() )
				}	 
				state("waiting_for_measurement") { //this:State
					action { //it:State
						//genTimer( actor, state )
					}
					//After Lenzi Aug2002
					sysaction { //it:State
					}	 	 
					 transition(edgeName="t00",targetState="handle_measurement",cond=whenEvent("sonardata"))
				}	 
				state("handle_measurement") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("distance(X)"), Term.createTerm("distance(X)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								 
												val M = payloadArg(0).toInt()	
												CounterMisurazioni++
								if(   M < DFREE/2  
								 ){ 
								                    Stato = CONTAINER_PRESENTE
								if(  Guasto  
								 ){CommUtils.outgreen("$name | sonar ripristinato")
								 Guasto = false  
								emit("problem_solved", "problem_solved(CAUSA)" ) 
								}
								}
								if(  M >= DFREE/2 && M <= DFREE  
								 ){ 
								                    Stato = CONTAINER_ASSENTE
								if(  Guasto  
								 ){CommUtils.outgreen("$name | sonar ripristinato")
								 Guasto = false  
								emitLocalStreamEvent("led_off", "led_off(yes)" ) 
								emit("problem_solved", "problem_solved(CAUSA)" ) 
								}
								}
								if(  M > DFREE  
								 ){ 
													Stato = GUASTO
								emitLocalStreamEvent("led_on", "led_on(yes)" ) 
								}
								
												if(Stato == Stato_precedente &&
								                   Stato_precedente!=START)
								                {
													when(Stato) {
													    CONTAINER_PRESENTE -> {
													        if(CounterMisurazioni == 3) {
													        	CommUtils.outmagenta("Ho letto 3 volte una misura congruente quindi procedo a segnalare la presenza di un container")
								emit("container_trigger", "container_trigger(1)" ) 
								
													    		//CounterMisurazioni = 0 non voglio che arrivi più volte l'evento
													    			}
													    		}
													    CONTAINER_ASSENTE -> {
													    	if(CounterMisurazioni == 3) {
													        	CommUtils.outmagenta("Ho letto 3 volte una misura congruente quindi non c'è più il container'")
													    		//CounterMisurazioni = 0
													    							}
													    					}
													    GUASTO -> {
													    	if(CounterMisurazioni == 3) {
																CommUtils.outred("Guasto")	
																Guasto = true
								emit("sonar_error", "sonar_error(CAUSA)" ) 
								
																//CounterMisurazioni = 0			    		
													    								}
													    		}
													    else -> {
													    	println("Non posso entrare in questo stato, preoccupati")
													    }
													}
												} 
												else {
													Stato_precedente = Stato
													CounterMisurazioni = 1
												}
												
						}
						//genTimer( actor, state )
					}
					//After Lenzi Aug2002
					sysaction { //it:State
					}	 	 
					 transition( edgeName="goto",targetState="waiting_for_measurement", cond=doswitch() )
				}	 
			}
		}
} 
